<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Universe of a Potato - Orbital Layers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #050302; 
            font-family: 'Inter', system-ui, -apple-system, sans-serif; 
            color: #d2b48c; 
        }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 40px; box-sizing: border-box;
            z-index: 10;
        }

        .header h1 { 
            margin: 0; 
            font-size: 1.8rem; 
            font-weight: 300;
            letter-spacing: 0.3em; 
            text-transform: uppercase; 
            background: linear-gradient(90deg, #8b7355, #d2b48c, #8b7355);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0.9; 
        }
        
        .status-indicator { 
            font-family: 'Courier New', monospace; 
            font-size: 0.8rem; 
            color: #8b7355; 
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-dot { width: 8px; height: 8px; background: #8b7355; border-radius: 50%; }

        #cursor {
            position: absolute;
            width: 40px; height: 40px;
            border: 1px solid rgba(210, 180, 140, 0.4); 
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            transition: width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        height 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                        background 0.3s, border-color 0.3s;
            z-index: 100;
        }
        
        #cursor::after {
            content: '';
            position: absolute;
            inset: 50%;
            width: 4px; height: 4px;
            background: #d2b48c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #cursor.previewing { 
            width: 24px; height: 24px; 
            background: rgba(255, 215, 0, 0.1); 
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }
        
        #cursor.dragging {
            width: 60px; height: 60px;
            border-style: dashed;
            border-color: rgba(210, 180, 140, 0.8);
            background: rgba(210, 180, 140, 0.05);
        }
        
        #cursor.resetting {
            width: 12px; height: 12px;
            border-color: #ff4444;
            background: #ff4444;
            box-shadow: 0 0 30px #ff4444;
        }

        #video-preview {
            position: absolute; bottom: 30px; right: 30px;
            width: 160px; height: 120px;
            border: 1px solid rgba(139, 115, 85, 0.3);
            border-radius: 16px; overflow: hidden;
            transform: scaleX(-1);
            background: #000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #input_video { width: 100%; height: 100%; object-fit: cover; opacity: 0.6; }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        #feedback-hint {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem; font-weight: 200; opacity: 0; pointer-events: none;
            letter-spacing: 0.5em; color: #fff;
            text-shadow: 0 0 30px rgba(210, 180, 140, 0.5);
            text-align: center;
            z-index: 5;
        }

        #loading {
            position: fixed; inset: 0; background: #050302;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 1.5s;
        }
        .loader-ring { width: 60px; height: 60px; border: 2px solid rgba(139, 115, 85, 0.2); border-top-color: #d2b48c; border-radius: 50%; animation: spin 1.5s infinite cubic-bezier(0.5, 0, 0.5, 1); }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="loading">
    <div class="loader-ring"></div>
    <p style="margin-top: 24px; letter-spacing: 0.2em; font-weight: 200;">å–šé†’è–¯ä»”ç©ºé–“...</p>
</div>

<div id="ui-layer">
    <div class="header">
        <h1>Potato Universe</h1>
        <div class="status-indicator">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">å°±ç·’</span>
        </div>
    </div>
    <div id="hint-text" style="text-align: center; font-weight: 300; opacity: 0.5; font-size: 0.8rem; letter-spacing: 0.1em; line-height: 2;">
        ğŸ–ï¸ å¼µé–‹æ‰‹æŒ: å–šé†’è¨˜æ†¶ | ğŸ¤ æåˆæ‰‹æŒ‡: é–å®šç¢ç‰‡<br>
        ğŸŒŒ ç©ºç™½è™•æåˆ: æ—‹è½‰è»Œé“ | ğŸ‘‹ æ”¾é–‹æ‰‹æŒ‡: æ·±åº¦å›æœ› | âœŠ æ¡ç·Šæ‹³é ­: å›æ­¸å¡µåŸƒ
    </div>
</div>

<div id="cursor"></div>
<div id="feedback-hint"></div>

<div id="video-preview">
    <audio id="bg-music" loop src="Is that you.mp3"></audio>
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>

<script>
/**
 * è³‡æºæ¸…å–®
 */
const MY_ASSETS = [
    { type: 'image', url: 'media/1.jpg' },
    { type: 'image', url: 'media/2.jpg' },
    { type: 'image', url: 'media/3.jpg' },
    { type: 'image', url: 'media/4.jpg' },
    { type: 'image', url: 'media/5.jpg' },
    { type: 'image', url: 'media/6.jpg' },
    { type: 'image', url: 'media/7.jpg' },
    { type: 'image', url: 'media/8.jpg' },
    { type: 'image', url: 'media/9.jpg' },
    { type: 'image', url: 'media/10.jpg' },
    { type: 'image', url: 'media/11.jpg' },
    { type: 'image', url: 'media/12.jpg' },
    { type: 'image', url: 'media/13.jpg' },
    { type: 'image', url: 'media/14.jpg' },
    { type: 'image', url: 'media/15.jpg' },
    { type: 'image', url: 'media/16.jpg' },
    { type: 'image', url: 'media/17.jpg' },
    { type: 'image', url: 'media/18.jpg' },
    { type: 'image', url: 'media/19.jpg' },
    { type: 'image', url: 'media/20.jpg' },
    { type: 'image', url: 'media/21.jpg' },
    { type: 'image', url: 'media/22.jpg' },
    { type: 'image', url: 'media/23.jpg' },
    { type: 'video', url: 'media/a.mp4' },
    { type: 'video', url: 'media/b.mp4' },
    { type: 'video', url: 'media/c.mp4' }
];

const CONFIG = {
    PARTICLE_COUNT: 22000,
    POTATO_COLOR: 0x8b7355,
    ACCENT_COLOR: 0xd2b48c,
    SMOOTHING: 0.15,
    DRAG_SENSITIVITY: 2.5,
    PHOTO_BASE_WIDTH: 200, 
    LAYER_RADII: [450, 700, 950], 
    ORBIT_SPEEDS: [0.0012, 0.0008, 0.0005],
    FOCUS_Z: 550 // ç›¸æ©Ÿå‰æ–¹ Z è»¸ç›®æ¨™ä½ç½® (ä¸–ç•Œåæ¨™)
};

const STATES = {
    IDLE: 'æ²‰ç¡ä¸­',
    EXPLODED: 'é€²å…¥å›æ†¶ğŸ¥”',
    PREVIEWING: 'è®€å–ä¸­',
    FOCUSED: 'æ·±åº¦å›æœ›'
};

let currentState = STATES.IDLE;
let scene, camera, renderer, potatoPoints, starField, photoGroup;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let smoothMouse = new THREE.Vector2();
let hoveredPhoto = null;
let selectedPhoto = null;
let isDraggingView = false; 

let gestureTimers = { palm: null, fist: null };
let bgMusic = document.getElementById('bg-music');
let isMusicPlaying = false;

const AudioController = {
    ctx: null,
    init() { 
        if(!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    play(freq, duration, type='sine', volume=0.05) {
        this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        gain.gain.setValueAtTime(volume, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050302);
    scene.fog = new THREE.FogExp2(0x050302, 0.0004);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 6000);
    camera.position.z = 1000; 

    renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    const pointLight = new THREE.PointLight(CONFIG.ACCENT_COLOR, 3, 1500);
    pointLight.position.set(300, 300, 400);
    scene.add(pointLight);

    createBackgroundStars();
    createPotatoParticles();
    createPhotoGallery();
    
    window.addEventListener('resize', onWindowResize);
}

function createBackgroundStars() {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(5000 * 3);
    for (let i = 0; i < 5000; i++) {
        pos[i*3] = (Math.random() - 0.5) * 4000;
        pos[i*3+1] = (Math.random() - 0.5) * 4000;
        pos[i*3+2] = (Math.random() - 0.5) * 4000;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({ color: 0x443322, size: 1.5, transparent: true, opacity: 0.5 });
    starField = new THREE.Points(geo, mat);
    scene.add(starField);
}

function createPotatoParticles() {
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(CONFIG.PARTICLE_COUNT * 3);
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const p = getPotatoPoint();
        pos[i * 3] = p.x;
        pos[i * 3 + 1] = p.y;
        pos[i * 3 + 2] = p.z;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const mat = new THREE.PointsMaterial({
        color: CONFIG.POTATO_COLOR, size: 2.0, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
    });
    potatoPoints = new THREE.Points(geo, mat);
    scene.add(potatoPoints);
}

function getPotatoPoint() {
    const u = Math.random() * Math.PI * 2;
    const v = Math.random() * Math.PI;
    const r = 140 + (Math.random() * 15);
    const noise = Math.sin(u * 2) * 15 + Math.cos(v * 4) * 12 + (Math.random() * 5);
    return {
        x: (r + noise) * 1.35 * Math.sin(v) * Math.cos(u),
        y: (r + noise) * 0.95 * Math.sin(v) * Math.sin(u),
        z: (r + noise) * 0.90 * Math.cos(v)
    };
}

function createPhotoGallery() {
    if (photoGroup) scene.remove(photoGroup);
    photoGroup = new THREE.Group();
    const loader = new THREE.TextureLoader();

    MY_ASSETS.forEach((asset, i) => {
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshStandardMaterial({ 
            transparent: true, opacity: 0, side: THREE.DoubleSide, 
            emissive: 0x221105, emissiveIntensity: 0.1 
        });
        const mesh = new THREE.Mesh(geometry, material);

        let videoEl = null;

        const setAssetScale = (width, height) => {
            const aspect = height / width; 
            let baseW = CONFIG.PHOTO_BASE_WIDTH;
            if (aspect > 1.2) baseW *= 0.8; 
            const targetScale = new THREE.Vector3(baseW, baseW * aspect, 1);
            mesh.userData.targetScale = targetScale;
            mesh.userData.aspect = aspect;
            mesh.userData.rawWidth = width;
            mesh.userData.rawHeight = height;
            mesh.userData.isPortrait = aspect > 1; 
            if (currentState !== STATES.IDLE) mesh.scale.copy(targetScale);
        };

        if (asset.type === 'video') {
            videoEl = document.createElement('video');
            videoEl.src = asset.url;
            videoEl.loop = true;
            videoEl.muted = true; 
            videoEl.playsInline = true;
            videoEl.crossOrigin = "anonymous";
            videoEl.onloadedmetadata = () => setAssetScale(videoEl.videoWidth, videoEl.videoHeight);
            const videoTex = new THREE.VideoTexture(videoEl);
            mesh.material.map = videoTex;
        } else {
            const tex = loader.load(asset.url, (t) => setAssetScale(t.image.width, t.image.height));
            mesh.material.map = tex;
        }

        const layerIndex = i % CONFIG.LAYER_RADII.length;
        const radius = CONFIG.LAYER_RADII[layerIndex];
        const angle = (Math.floor(i / CONFIG.LAYER_RADII.length) / (MY_ASSETS.length / CONFIG.LAYER_RADII.length)) * Math.PI * 2;
        const heightVariation = (Math.random() - 0.5) * 400; 
        
        mesh.position.set(Math.cos(angle) * radius, heightVariation + Math.sin(angle * 2) * 50, Math.sin(angle) * radius);
        
        mesh.userData.id = i;
        mesh.userData.type = asset.type;
        mesh.userData.video = videoEl;
        mesh.userData.originalPos = mesh.position.clone();
        mesh.userData.layerIndex = layerIndex;
        mesh.userData.orbitAngle = angle;      
        mesh.userData.targetScale = new THREE.Vector3(CONFIG.PHOTO_BASE_WIDTH, CONFIG.PHOTO_BASE_WIDTH, 1); 
        
        mesh.lookAt(0, 0, 0);
        photoGroup.add(mesh);
    });
    scene.add(photoGroup);
}

function updateState(newState, target = null) {
    if (currentState === newState && newState !== STATES.PREVIEWING) return;
    const oldState = currentState;
    currentState = newState;
    document.getElementById('status-text').innerText = newState;

    switch(newState) {
        case STATES.IDLE:
            animatePotato(false);
            togglePhotos(0);
            if (isMusicPlaying) {
                gsap.to(bgMusic, { volume: 0, duration: 2, onComplete: () => { bgMusic.pause(); isMusicPlaying = false; }});
            }
            if (selectedPhoto) resetPhoto(selectedPhoto);
            gsap.to(photoGroup.rotation, { x: 0, y: 0, z: 0, duration: 2 }); 
            AudioController.play(120, 1.5, 'sine');
            showFeedback("ç™»å‡ºğŸ¥”ä¸–ç•Œ");
            gsap.to("#status-dot", { background: "#8b7355", scale: 1, duration: 0.5 });
            break;

        case STATES.EXPLODED:
            animatePotato(true);
            togglePhotos(1);
            if (!isMusicPlaying) {
                bgMusic.volume = 0;
                bgMusic.play().then(() => {
                    isMusicPlaying = true;
                    gsap.to(bgMusic, { volume: 0.5, duration: 3 });
                }).catch(e => console.log("ç­‰å¾…æ‰‹å‹¢äº¤äº’"));
            }
            photoGroup.children.forEach(p => {
                if (p.userData.type === 'video' && p.userData.video) p.userData.video.pause();
                gsap.to(p.material, { opacity: 1, duration: 0.5 });
            });

            if (oldState === STATES.FOCUSED || oldState === STATES.IDLE) {
                AudioController.play(350, 0.8, 'sine');
                showFeedback("ç™»å…¥ğŸ¥”ä¸–ç•Œ");
            }
            gsap.to("#status-dot", { background: "#d2b48c", scale: 1.2, duration: 0.5 });
            break;

        case STATES.PREVIEWING:
            selectedPhoto = target;
            photoGroup.children.forEach(p => {
                if (p !== target) gsap.to(p.material, { opacity: 0.05, duration: 0.4 });
            });
            const zoomScale = target.userData.targetScale.clone().multiplyScalar(1.1);
            gsap.to(target.scale, { x: zoomScale.x, y: zoomScale.y, duration: 0.4 });
            cursorEl.classList.add('previewing');
            break;

        case STATES.FOCUSED:
            if (selectedPhoto) {
                // --- 1. è‡ªé©æ‡‰å¤§åœ–æ¯”ä¾‹è¨ˆç®— ---
                const distToCam = camera.position.z - CONFIG.FOCUS_Z;
                const vFOV = THREE.MathUtils.degToRad(camera.fov);
                const visibleHeight = 2 * Math.tan(vFOV / 2) * distToCam;
                const visibleWidth = visibleHeight * camera.aspect;
                
                const imgAspect = selectedPhoto.userData.aspect; // height / width
                
                // æ ¹æ“šè¦æ±‚ï¼šæ©«å‘ 0.5ï¼Œè±å‘æ›´å° 0.35
                const zoomFactor = (imgAspect < 1) ? 0.5 : 0.3;
                
                let finalScaleX, finalScaleY;
                if (imgAspect > camera.aspect) {
                    finalScaleY = visibleHeight * zoomFactor;
                    finalScaleX = finalScaleY / imgAspect;
                } else {
                    finalScaleX = visibleWidth * zoomFactor;
                    finalScaleY = finalScaleX * imgAspect;
                }

                // --- 2. å±•ç¤ºæ–¹å‘èˆ‡ä½ç½®æ ¡æº– ---
                // ç›®æ¨™ï¼šåœ¨ä¸–ç•Œåæ¨™ç³»ä¸‹æ­£å°ç›¸æ©Ÿã€‚ç”±æ–¼å®ƒæ˜¯ photoGroup çš„å­å°è±¡ï¼Œæˆ‘å€‘éœ€è¦è€ƒæ…®çˆ¶å®¹å™¨çš„æ—‹è½‰ã€‚
                const targetWorldPos = new THREE.Vector3(0, 0, CONFIG.FOCUS_Z);
                const localPos = selectedPhoto.parent.worldToLocal(targetWorldPos.clone());
                
                // å‹•ç•«ï¼šç§»å‹•åˆ°ç›®æ¨™ä½ç½®
                gsap.to(selectedPhoto.position, { 
                    x: localPos.x, y: localPos.y, z: localPos.z, 
                    duration: 1.2, ease: "expo.out" 
                });
                
                // å‹•ç•«ï¼šåå‘æ—‹è½‰ä»¥æŠµæ¶ˆ photoGroup çš„æ—‹è½‰ï¼Œä½¿å…¶æ­£å°ç›¸æ©Ÿ
                gsap.to(selectedPhoto.rotation, { 
                    x: -photoGroup.rotation.x, 
                    y: -photoGroup.rotation.y, 
                    z: 0, 
                    duration: 1.2,
                    ease: "expo.out"
                });

                // å‹•ç”»ï¼šç¸®æ”¾
                gsap.to(selectedPhoto.scale, { 
                    x: finalScaleX, y: finalScaleY, 
                    duration: 1.2, ease: "expo.out" 
                });

                gsap.to(potatoPoints.material, { opacity: 0.05, duration: 1.5 });
                if (selectedPhoto.userData.type === 'video') selectedPhoto.userData.video.play();

                AudioController.play(520, 1.2, 'sine');
                showFeedback("å›æœ›ç¢ç‰‡");
            }
            cursorEl.classList.remove('previewing');
            break;
    }
}

function animatePotato(isExplode) {
    const posAttr = potatoPoints.geometry.attributes.position;
    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
        const dest = isExplode ? 
            { x: (Math.random()-0.5)*2800, y: (Math.random()-0.5)*2800, z: (Math.random()-0.5)*2800 } :
            getPotatoPoint();
        gsap.to(posAttr.array, {
            [i*3]: dest.x, [i*3+1]: dest.y, [i*3+2]: dest.z,
            duration: 1.5 + Math.random(),
            ease: isExplode ? "power2.out" : "elastic.out(1, 0.75)",
            onUpdate: () => posAttr.needsUpdate = true
        });
    }
    gsap.to(potatoPoints.material, { opacity: isExplode ? 0.35 : 0.8, duration: 1.5 });
}

function togglePhotos(val) {
    photoGroup.children.forEach(p => {
        gsap.to(p.material, { opacity: val, duration: 1.2, ease: "power2.inOut" });
        if (val === 0) {
            gsap.to(p.scale, { x: 0.1, y: 0.1, duration: 0.8 });
        } else {
            const ts = p.userData.targetScale;
            gsap.to(p.scale, { x: ts.x, y: ts.y, z: 1, duration: 1.2, delay: 0.1 });
        }
    });
}

function resetPhoto(p) {
    if(!p) return;
    const orig = p.userData.originalPos;
    gsap.to(p.position, { x: orig.x, y: orig.y, z: orig.z, duration: 0.8, ease: "power2.inOut" });
    gsap.to(p.rotation, { y: 0, x: 0, duration: 0.8 });
    const ts = p.userData.targetScale;
    gsap.to(p.scale, { x: ts.x, y: ts.y, duration: 0.8 });
    if (p.userData.type === 'video' && p.userData.video) p.userData.video.pause();
    selectedPhoto = null;
}

const videoElement = document.getElementById('input_video');
const canvasElement = document.getElementById('output_canvas');
const canvasCtx = canvasElement.getContext('2d');
const cursorEl = document.getElementById('cursor');

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.7 });

hands.onResults((results) => {
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        AudioController.init();
        const landmarks = results.multiHandLandmarks[0];
        drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgba(210, 180, 140, 0.8)', lineWidth: 3});
        drawLandmarks(canvasCtx, landmarks, {color: '#d2b48c', lineWidth: 1, radius: 3});
        
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];
        const targetX = (1 - indexTip.x) * window.innerWidth;
        const targetY = indexTip.y * window.innerHeight;
        smoothMouse.x += (targetX - smoothMouse.x) * CONFIG.SMOOTHING;
        smoothMouse.y += (targetY - smoothMouse.y) * CONFIG.SMOOTHING;
        cursorEl.style.left = `${smoothMouse.x}px`;
        cursorEl.style.top = `${smoothMouse.y}px`;
        cursorEl.style.display = 'block';

        const prevMouse = mouse.clone();
        mouse.x = (smoothMouse.x / window.innerWidth) * 2 - 1;
        mouse.y = -(smoothMouse.y / window.innerHeight) * 2 + 1;
        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
        const isPinching = pinchDist < 0.05;

        if (checkIsFist(landmarks)) {
            cursorEl.classList.add('resetting'); 
            if (!gestureTimers.fist) gestureTimers.fist = Date.now();
            if (Date.now() - gestureTimers.fist > 800) { updateState(STATES.IDLE); gestureTimers.fist = null; }
        } else {
            cursorEl.classList.remove('resetting');
            gestureTimers.fist = null;
        }

        if (currentState === STATES.IDLE && checkIsPalm(landmarks)) {
            if (!gestureTimers.palm) gestureTimers.palm = Date.now();
            if (Date.now() - gestureTimers.palm > 800) { updateState(STATES.EXPLODED); gestureTimers.palm = null; }
        } else { gestureTimers.palm = null; }

        if (currentState === STATES.EXPLODED || currentState === STATES.FOCUSED) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(photoGroup.children);
            
            if (isPinching) {
                if (currentState === STATES.EXPLODED && intersects.length > 0 && !isDraggingView) {
                    updateState(STATES.PREVIEWING, intersects[0].object);
                } else if (currentState === STATES.EXPLODED) {
                    isDraggingView = true;
                    cursorEl.classList.add('dragging');
                    photoGroup.rotation.y += (mouse.x - prevMouse.x) * CONFIG.DRAG_SENSITIVITY;
                    photoGroup.rotation.x -= (mouse.y - prevMouse.y) * CONFIG.DRAG_SENSITIVITY;
                } else if (currentState === STATES.FOCUSED) {
                    resetPhoto(selectedPhoto);
                    updateState(STATES.EXPLODED);
                }
            } else {
                isDraggingView = false;
                cursorEl.classList.remove('dragging');
                if (currentState === STATES.EXPLODED && intersects.length > 0) {
                    const target = intersects[0].object;
                    if (hoveredPhoto !== target) {
                        if (hoveredPhoto) gsap.to(hoveredPhoto.scale, { x: hoveredPhoto.userData.targetScale.x, y: hoveredPhoto.userData.targetScale.y, duration: 0.3 });
                        hoveredPhoto = target;
                        gsap.to(target.scale, { x: target.userData.targetScale.x * 1.15, y: target.userData.targetScale.y * 1.15, duration: 0.4 });
                        AudioController.play(400, 0.1, 'sine', 0.02);
                    }
                } else if (hoveredPhoto) {
                    gsap.to(hoveredPhoto.scale, { x: hoveredPhoto.userData.targetScale.x, y: hoveredPhoto.userData.targetScale.y, duration: 0.3 });
                    hoveredPhoto = null;
                }
            }
        } 
        else if (currentState === STATES.PREVIEWING && !isPinching) {
            updateState(STATES.FOCUSED);
        }
    } else {
        cursorEl.style.display = 'none';
        isDraggingView = false;
    }
    canvasCtx.restore();
});

function checkIsFist(l) {
    const palm = l[0];
    const fingers = [8, 12, 16, 20];
    return fingers.every(i => Math.hypot(l[i].x - palm.x, l[i].y - palm.y) < 0.22);
}

function checkIsPalm(l) {
    const palm = l[0];
    const fingers = [8, 12, 16, 20];
    return fingers.every(i => Math.hypot(l[i].x - palm.x, l[i].y - palm.y) > 0.3);
}

function showFeedback(text) {
    const el = document.getElementById('feedback-hint');
    el.innerText = text;
    gsap.fromTo(el, { opacity: 1, scale: 0.7, y: 20 }, { opacity: 0, scale: 1.3, y: -20, duration: 2.5, ease: "power2.out" });
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (currentState === STATES.FOCUSED && selectedPhoto) {
        updateState(STATES.FOCUSED, selectedPhoto);
    }
}

function animate() {
    requestAnimationFrame(animate);
    const time = Date.now();
    
    if (starField) starField.rotation.y += 0.00018;
    if (potatoPoints) {
        potatoPoints.rotation.y += 0.00045;
        if (isDraggingView) {
            potatoPoints.rotation.y = photoGroup.rotation.y * 0.45;
            potatoPoints.rotation.x = photoGroup.rotation.x * 0.45;
        }
    }
    
    if (photoGroup && (currentState === STATES.EXPLODED || currentState === STATES.FOCUSED || currentState === STATES.PREVIEWING)) {
        if (!isDraggingView && currentState === STATES.EXPLODED) photoGroup.rotation.y += 0.0004;
        
        photoGroup.children.forEach((p, i) => {
            // --- æ·±åº¦å›æœ›ç‹€æ…‹ä¸‹çš„æ‰‹éƒ¨è·Ÿéš¨å¾®èª¿ (Tilting) ---
            if (currentState === STATES.FOCUSED && p === selectedPhoto) {
                // åŸºç¤æ—‹è½¬ï¼šæŠµæ¶ˆçˆ¶å®¹å™¨ï¼Œä½¿å…¶æ­£å°ç›¸æ©Ÿ
                const baseRX = -photoGroup.rotation.x;
                const baseRY = -photoGroup.rotation.y;
                
                // åç§»é‡ï¼šæ ¹æ“š mouse ä½ç½®ç”¢ç”Ÿ 3D å‚¾æ–œæ„Ÿ (Tilting)
                const tiltX = baseRX + (mouse.y * 0.25);
                const tiltY = baseRY + (mouse.x * 0.25);
                
                // å¹³æ»‘æ’å€¼
                p.rotation.x += (tiltX - p.rotation.x) * 0.1;
                p.rotation.y += (tiltY - p.rotation.y) * 0.1;
                return; 
            }
            
            const layerIdx = p.userData.layerIndex;
            const orbitSpeed = CONFIG.ORBIT_SPEEDS[layerIdx];
            p.userData.orbitAngle += orbitSpeed;
            
            const radius = CONFIG.LAYER_RADII[layerIdx];
            const targetX = Math.cos(p.userData.orbitAngle) * radius;
            const targetZ = Math.sin(p.userData.orbitAngle) * radius;
            
            p.userData.originalPos.x = targetX;
            p.userData.originalPos.z = targetZ;
            
            p.position.x = targetX;
            p.position.z = targetZ;
            p.position.y = p.userData.originalPos.y + Math.sin(time * 0.001 + i) * 10;
            p.rotation.z = Math.sin(time * 0.0005 + i) * 0.045;
            p.lookAt(0, 0, 0);
        });
    }
    renderer.render(scene, camera);
}

const cameraInst = new Camera(videoElement, {
    onFrame: async () => {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        await hands.send({image: videoElement});
    },
    width: 640, height: 480
});

window.onload = () => {
    init();
    animate();
    cameraInst.start().then(() => {
        gsap.to("#loading", { opacity: 0, duration: 1.5, onComplete: () => document.getElementById('loading').style.display = 'none' });
    });
};
</script>
</body>
</html>